<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Design Patterns in Rust</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./styles.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="creational/intro.html"><strong aria-hidden="true">2.</strong> Creational</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="creational/singleton.html"><strong aria-hidden="true">2.1.</strong> Singleton</a></li><li class="chapter-item "><a href="creational/builder.html"><strong aria-hidden="true">2.2.</strong> Builder</a></li><li class="chapter-item "><a href="creational/factory.html"><strong aria-hidden="true">2.3.</strong> Factory</a></li><li class="chapter-item "><a href="creational/prototype.html"><strong aria-hidden="true">2.4.</strong> Prototype</a></li></ol></li><li class="chapter-item expanded "><a href="structural/intro.html"><strong aria-hidden="true">3.</strong> Structural</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="structural/adaptor.html"><strong aria-hidden="true">3.1.</strong> Adaptor</a></li><li class="chapter-item "><a href="structural/bridge.html"><strong aria-hidden="true">3.2.</strong> Bridge</a></li><li class="chapter-item "><a href="structural/composite.html"><strong aria-hidden="true">3.3.</strong> Composite</a></li><li class="chapter-item "><a href="structural/decorator.html"><strong aria-hidden="true">3.4.</strong> Decorator</a></li><li class="chapter-item "><a href="structural/facade.html"><strong aria-hidden="true">3.5.</strong> Facade</a></li><li class="chapter-item "><a href="structural/flyweight.html"><strong aria-hidden="true">3.6.</strong> Flyweight</a></li><li class="chapter-item "><a href="structural/proxy.html"><strong aria-hidden="true">3.7.</strong> Proxy</a></li></ol></li><li class="chapter-item expanded "><a href="behavioral/intro.html"><strong aria-hidden="true">4.</strong> Behavioral</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="behavioral/observer.html"><strong aria-hidden="true">4.1.</strong> Observer</a></li><li class="chapter-item "><a href="behavioral/state.html"><strong aria-hidden="true">4.2.</strong> State</a></li><li class="chapter-item "><a href="behavioral/strategy.html"><strong aria-hidden="true">4.3.</strong> Strategy</a></li><li class="chapter-item "><a href="behavioral/command.html"><strong aria-hidden="true">4.4.</strong> Command</a></li><li class="chapter-item "><a href="behavioral/visitor.html"><strong aria-hidden="true">4.5.</strong> Visitor</a></li><li class="chapter-item "><a href="behavioral/iterator.html"><strong aria-hidden="true">4.6.</strong> Iterator</a></li><li class="chapter-item "><a href="behavioral/chain-of-responsibility.html"><strong aria-hidden="true">4.7.</strong> Chain of Responsibility</a></li><li class="chapter-item "><a href="behavioral/mediator.html"><strong aria-hidden="true">4.8.</strong> Mediator</a></li><li class="chapter-item "><a href="behavioral/memento.html"><strong aria-hidden="true">4.9.</strong> Memento</a></li><li class="chapter-item "><a href="behavioral/interpreter.html"><strong aria-hidden="true">4.10.</strong> Interpreter</a></li><li class="chapter-item "><a href="behavioral/template.html"><strong aria-hidden="true">4.11.</strong> Template</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Design Patterns in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction-to-design-patterns-in-rust"><a class="header" href="#introduction-to-design-patterns-in-rust">Introduction to Design Patterns in Rust</a></h1>
<p>Design patterns are proven solutions to recurring software design problems that developers can use to solve common design challenges. They provide a structured approach to designing software systems that are flexible, maintainable, and scalable. Design patterns help in achieving code that is modular, reusable, and follows best practices.</p>
<p>Rust, with its emphasis on performance, safety, and concurrency, provides a robust language for building reliable systems. Design patterns in Rust serve as guidelines to leverage the language features effectively and tackle common design problems specific to Rust.</p>
<p>In this guide, we explore various design patterns tailored for Rust programming. Each design pattern focuses on a specific problem and provides a recommended solution. We delve into their concepts, implementation techniques, and real-world use cases to demonstrate their practical applicability in Rust projects.</p>
<p>Whether you are a beginner looking to expand your understanding of software design principles or an experienced Rust developer seeking to enhance your architectural skills, this guide will serve as a valuable resource. By mastering design patterns in Rust, you will be equipped with powerful tools to build robust, maintainable, and efficient software systems.</p>
<p>Let's embark on this journey of exploring design patterns in Rust and discover how they can elevate the quality and elegance of your code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creational-design-patterns"><a class="header" href="#creational-design-patterns">Creational Design Patterns</a></h1>
<p>Creational design patterns are a set of patterns that deal with the object creation process. They focus on providing flexible ways to create objects, allowing for decoupling of object creation from their implementation. These patterns enhance the reusability, maintainability, and flexibility of a system's design by tailoring the object creation mechanisms to specific situations.</p>
<h2 id="common-creational-design-patterns"><a class="header" href="#common-creational-design-patterns">Common Creational Design Patterns</a></h2>
<ol>
<li>
<p><span class="usecase-heading"><strong>Singleton</strong></span>: Ensures that only one instance of a class is created, providing a global point of access to that instance.</p>
</li>
<li>
<p><span class="usecase-heading"><strong>Builder</strong></span>: Separates the construction of complex objects from their representation, allowing the same construction process to create different representations.</p>
</li>
<li>
<p><span class="usecase-heading"><strong>Factory</strong></span>: Defines an interface for creating objects but allows subclasses to decide which class to instantiate.</p>
</li>
<li>
<p><span class="usecase-heading"><strong>Prototype</strong></span>: Creates objects by cloning existing instances, avoiding the need for subclassing.</p>
</li>
</ol>
<p>These are just a few examples of the creational design patterns commonly used in Rust. Each pattern addresses specific scenarios and provides unique benefits in terms of object creation and initialization. In the following sections, we will explore each pattern in detail, discussing their purpose, implementation, and usage in Rust.</p>
<h2 id="benefits-of-creational-design-patterns"><a class="header" href="#benefits-of-creational-design-patterns">Benefits of Creational Design Patterns</a></h2>
<ul>
<li>
<p><strong>Flexibility</strong>: Creational design patterns enable the creation of objects in a flexible manner, adapting to the requirements of a given situation.</p>
</li>
<li>
<p><strong>Decoupling</strong>: By separating object creation from implementation, these patterns promote decoupling, reducing dependencies and making the system more maintainable.</p>
</li>
<li>
<p><strong>Enhanced Reusability</strong>: The use of creational design patterns often results in code that is more reusable, allowing for the creation of objects in various contexts.</p>
</li>
<li>
<p><strong>Improved Design and Architecture</strong>: These patterns contribute to better overall system design and architecture by providing more suitable and effective ways of creating objects.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="singleton-pattern"><a class="header" href="#singleton-pattern">Singleton Pattern</a></h1>
<p>The Singleton pattern is a creational design pattern that ensures the creation of only one instance of a class throughout the lifetime of an application. It provides a global point of access to this instance.</p>
<h3 id="examples"><a class="header" href="#examples">Examples:</a></h3>
<hr />
<pre><pre class="playground"><code class="language-rust">use lazy_static::lazy_static;
use std::sync::{Arc, Mutex};
struct Singleton {
    data: String,
}

impl Singleton {
    fn new() -&gt; Singleton {
        Singleton {
            data: String::from(&quot;Singleton Data&quot;),
        }
    }

    fn get_instance() -&gt; Arc&lt;Singleton&gt; {
        lazy_static! {
            static ref INSTANCE: Mutex&lt;Option&lt;Arc&lt;Singleton&gt;&gt;&gt; = Mutex::new(None);
        }

        let mut instance = INSTANCE.lock().unwrap();
        if instance.is_none() {
            *instance = Some(Arc::new(Singleton::new()));
        }
        Arc::clone(instance.as_ref().unwrap())
    }

    fn get_data(&amp;self) -&gt; &amp;str {
        &amp;self.data
    }
}

fn main() {
    let singleton = Singleton::get_instance();
    println!(&quot;Singleton Data: {}&quot;, singleton.get_data());
}
</code></pre></pre>
<pre><code class="language-toml">[dependencies]
lazy_static = &quot;1.4.0&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builder-pattern"><a class="header" href="#builder-pattern">Builder Pattern</a></h1>
<p>The Builder pattern is a creational design pattern that allows for the construction of complex objects step by step. It provides a clear and readable way to create objects with many optional parameters or complex initialization logic.</p>
<h3 id="examples-1"><a class="header" href="#examples-1">Examples:</a></h3>
<hr />
<pre><pre class="playground"><code class="language-rust">#[derive(Debug)]
struct Pizza {
    base: Option&lt;String&gt;,
    sauce: Option&lt;String&gt;,
    toppings: Vec&lt;String&gt;,
    // ... other optional parameters
}

struct PizzaBuilder {
    pizza: Pizza,
}

impl PizzaBuilder {
    fn new() -&gt; Self {
        PizzaBuilder {
            pizza: Pizza {
                base: None,
                sauce: None,
                toppings: Vec::new(),
                // ... initialize other optional parameters
            },
        }
    }

    fn add_base(mut self, base: String) -&gt; Self {
        self.pizza.base = Some(base);
        self
    }

    fn add_sauce(mut self, sauce: String) -&gt; Self {
        self.pizza.sauce = Some(sauce);
        self
    }

    fn add_topping(mut self, topping: String) -&gt; Self {
        self.pizza.toppings.push(topping);
        self
    }

    // ... other setter methods for optional parameters

    fn build(self) -&gt; Option&lt;Pizza&gt; {
        if !self.pizza.base.is_none() &amp;&amp; !self.pizza.sauce.is_none() {
            Some(self.pizza)
        } else {
            None
        }
    }

    // OR
    //  fn build(self) -&gt; Pizza {
    //     self.pizza
    // }
}

fn main() {
    let pizza = PizzaBuilder::new()
        .add_base(&quot;Thin Crust&quot;.to_string())
        .add_sauce(&quot;Tomato&quot;.to_string())
        .add_topping(&quot;Cheese&quot;.to_string())
        .add_topping(&quot;Mushrooms&quot;.to_string())
        .build();

    match pizza {
        Some(pizza) =&gt; println!(&quot;Successfully built pizza: {:?}&quot;, pizza),
        None =&gt; println!(&quot;Failed to build pizza due to missing parameters&quot;),
    }
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="factory-pattern"><a class="header" href="#factory-pattern">Factory Pattern</a></h1>
<p>The Factory pattern is a creational design pattern that provides an interface for creating objects without specifying their concrete classes. It delegates the responsibility of object instantiation to subclasses or specialized factory methods. This pattern promotes loose coupling and encapsulates the object creation logic, allowing flexibility in creating different types of objects based on certain conditions or parameters.</p>
<h3 id="examples-2"><a class="header" href="#examples-2">Examples:</a></h3>
<hr />
<pre><pre class="playground"><code class="language-rust">trait Logger {
    fn log(&amp;self, message: &amp;str);
}

struct ConsoleLogger;
struct FileLogger;

impl Logger for ConsoleLogger {
    fn log(&amp;self, message: &amp;str) {
        println!(&quot;Logging to console: {}&quot;, message);
    }
}

impl Logger for FileLogger {
    fn log(&amp;self, message: &amp;str) {
        // Code for logging to a file
        println!(&quot;Logging to file: {}&quot;, message);
    }
}

enum LoggerType {
    Console,
    File,
}

struct LoggerFactory;

impl LoggerFactory {
    fn create_logger(&amp;self, logger_type: LoggerType) -&gt; Box&lt;dyn Logger&gt; {
        match logger_type {
            LoggerType::Console =&gt; Box::new(ConsoleLogger),
            LoggerType::File =&gt; Box::new(FileLogger),
        }
    }
}

struct App {
    logger: Box&lt;dyn Logger&gt;,
}

impl App {
    fn new(logger: Box&lt;dyn Logger&gt;) -&gt; Self {
        App { logger }
    }

    fn run(&amp;self) {
        self.logger.log(&quot;Application started&quot;);
        // Rest of the application logic
    }
}

fn main() {
    let factory = LoggerFactory;
    let logger_type = LoggerType::Console;

    let logger = factory.create_logger(logger_type);
    let app = App::new(logger);

    app.run();
}
</code></pre></pre>
<h3 id="for-testing-and-mocking-purpose"><a class="header" href="#for-testing-and-mocking-purpose">For Testing and Mocking Purpose:</a></h3>
<pre><pre class="playground"><code class="language-rust">// The trait representing the collaborator dependency
trait Collaborator {
    fn do_something(&amp;self);
}

// The concrete implementation of the collaborator
struct RealCollaborator;

impl Collaborator for RealCollaborator {
    fn do_something(&amp;self) {
        println!(&quot;RealCollaborator: Doing something real...&quot;);
        // Actual implementation of the collaborator's behavior
    }
}

// The factory that creates instances of the collaborator
struct CollaboratorFactory;

impl CollaboratorFactory {
    fn create_collaborator(&amp;self) -&gt; Box&lt;dyn Collaborator&gt; {
        // In a real scenario, this method can create and return a real collaborator
        Box::new(RealCollaborator)
    }
}

// The client code that uses the collaborator
struct Client {
    collaborator: Box&lt;dyn Collaborator&gt;,
}

impl Client {
    fn new(collaborator: Box&lt;dyn Collaborator&gt;) -&gt; Self {
        Client { collaborator }
    }

    fn perform_action(&amp;self) {
        // Do something using the collaborator
        self.collaborator.do_something();
    }
}

// The test/mock implementation of the collaborator
struct MockCollaborator;

impl Collaborator for MockCollaborator {
    fn do_something(&amp;self) {
        println!(&quot;MockCollaborator: Doing something mock...&quot;);
        // Custom implementation for testing purposes
    }
}

// The test code that uses the mocked collaborator
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_client_with_mock_collaborator() {
        let factory = CollaboratorFactory;
        let mock_collaborator = Box::new(MockCollaborator);

        let client = Client::new(mock_collaborator);
        client.perform_action();
        // Perform assertions on the client's behavior with the mock collaborator
    }
}

fn main() {
    let factory = CollaboratorFactory;
    let collaborator = factory.create_collaborator();

    let client = Client::new(collaborator);
    client.perform_action();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prototype-pattern"><a class="header" href="#prototype-pattern">Prototype Pattern</a></h1>
<p>The Prototype pattern is a creational design pattern that enables the creation of new objects by cloning existing ones, without coupling the code to specific classes. It involves creating a prototypical object and then creating new objects by copying the prototype. This pattern is particularly useful when object creation is complex or when there is a need to create multiple instances with similar initial state.</p>
<h3 id="examples-3"><a class="header" href="#examples-3">Examples:</a></h3>
<hr />
<pre><pre class="playground"><code class="language-rust">trait Prototype {
    fn clone(&amp;self) -&gt; Box&lt;dyn Prototype&gt;;
    fn draw(&amp;self);
}

#[derive(Clone)]
struct Circle {
    radius: f64,
}

impl Prototype for Circle {
    fn clone(&amp;self) -&gt; Box&lt;dyn Prototype&gt; {
        Box::new(self.clone())
    }

    fn draw(&amp;self) {
        println!(&quot;Drawing a circle with radius {}&quot;, self.radius);
    }
}

#[derive(Clone)]
struct Rectangle {
    width: f64,
    height: f64,
}

impl Prototype for Rectangle {
    fn clone(&amp;self) -&gt; Box&lt;dyn Prototype&gt; {
        Box::new(self.clone())
    }

    fn draw(&amp;self) {
        println!(&quot;Drawing a rectangle with width {} and height {}&quot;, self.width, self.height);
    }
}

fn main() {
    let circle_prototype: Box&lt;dyn Prototype&gt; = Box::new(Circle { radius: 5.0 });
    let rectangle_prototype: Box&lt;dyn Prototype&gt; = Box::new(Rectangle { width: 10.0, height: 8.0 });

    let shape1 = circle_prototype.clone();
    shape1.draw();

    let shape2 = rectangle_prototype.clone();
    shape2.draw();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structural-design-patterns"><a class="header" href="#structural-design-patterns">Structural Design Patterns</a></h1>
<p>Structural design patterns are a category of design patterns that focus on the composition and relationships between classes and objects to form larger structures and provide new functionality. They help in organizing and simplifying the relationships between different components of a system, promoting modularity, flexibility, and reusability. These patterns facilitate the design and maintenance of software systems by providing solutions for structural challenges such as managing complex relationships, adapting interfaces, or separating abstractions from their implementations.</p>
<h2 id="common-structural-design-patterns"><a class="header" href="#common-structural-design-patterns">Common Structural Design Patterns</a></h2>
<ol>
<li>
<p><span class="usecase-heading"><strong>Adapter Pattern</strong></span>: Converts the interface of a class into another interface that clients expect. It allows incompatible classes to work together by wrapping the adaptee with a compatible interface.</p>
</li>
<li>
<p><span class="usecase-heading"><strong>Bridge Pattern</strong></span>: Separates an abstraction from its implementation, allowing them to vary independently. It helps in decoupling an abstraction from its implementation details, promoting flexibility.</p>
</li>
<li>
<p><span class="usecase-heading"><strong>Composite Pattern</strong></span>: Composes objects into tree structures to represent part-whole hierarchies. It treats individual objects and compositions of objects uniformly, simplifying the interaction between them.</p>
</li>
<li>
<p><span class="usecase-heading"><strong>Decorator Pattern</strong></span>: Dynamically adds new behaviors or responsibilities to an object by wrapping it in a decorator class. It provides a flexible alternative to subclassing for extending functionality.</p>
</li>
<li>
<p><span class="usecase-heading"><strong>Facade Pattern</strong></span>: Provides a simplified interface to a complex subsystem, making it easier to use and understand. It hides the complexity of the underlying system and offers a unified interface.</p>
</li>
<li>
<p><span class="usecase-heading"><strong>Flyweight Pattern</strong></span>: Shares common state between multiple objects to reduce memory usage. It allows for efficient representation of large numbers of fine-grained objects.</p>
</li>
<li>
<p><span class="usecase-heading"><strong>Proxy Pattern</strong></span>: Provides a surrogate or placeholder for another object to control access to it. It allows for additional functionalities or restrictions to be applied to an object without changing its core implementation.</p>
</li>
</ol>
<p>These patterns, among others, offer solutions for various structural challenges and can be applied in different scenarios to improve the design and architecture of software systems.</p>
<h2 id="benefits-of-structural-design-patterns"><a class="header" href="#benefits-of-structural-design-patterns">Benefits of Structural Design Patterns</a></h2>
<p>Structural design patterns offer several benefits that can enhance the design and maintainability of software systems. Here are some of the key advantages:</p>
<ul>
<li>
<p><strong>Modularity and Reusability</strong>: Structural patterns promote modularity by organizing components into separate and cohesive units. This allows for easier reuse of existing components in different contexts, improving development efficiency and reducing duplication of code.</p>
</li>
<li>
<p><strong>Flexibility and Adaptability</strong>: These patterns enable the system to be more flexible and adaptable to changes. They provide mechanisms to modify the structure of objects and classes without affecting their behavior, allowing for easier introduction of new features or variations.</p>
</li>
<li>
<p><strong>Enhanced Extensibility</strong>: Structural patterns facilitate the addition of new functionalities or variations by extending the existing structure. They help in accommodating future requirements and making the system more scalable and extensible.</p>
</li>
<li>
<p><strong>Simplified Complexity</strong>: Complex relationships and interactions between classes and objects can be simplified and managed effectively using structural patterns. They provide clear and intuitive ways to represent and understand the system's architecture.</p>
</li>
<li>
<p><strong>Improved Maintainability</strong>: By promoting loose coupling and separation of concerns, structural patterns enhance the maintainability of the codebase. Changes or updates to one part of the system are less likely to have ripple effects on other components, making maintenance and debugging easier.</p>
</li>
<li>
<p><strong>Code Organization and Readability</strong>: Structural patterns provide guidelines for organizing code and relationships between components. This improves the readability and understandability of the codebase, making it easier for developers to collaborate and maintain the system over time.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adaptor-pattern"><a class="header" href="#adaptor-pattern">Adaptor Pattern</a></h1>
<p>Converts the interface of a class into another interface that clients expect. It allows incompatible classes to work together by wrapping the adaptee with a compatible interface.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<hr />
<pre><pre class="playground"><code class="language-rust">// Adaptee: Third-party SMS Service
struct ThirdPartySMS {
    api_key: String,
    api_secret: String,
}

impl ThirdPartySMS {
    fn send_sms(&amp;self, recipient: &amp;str, message: &amp;str) {
        println!(&quot;Sending SMS to {}: {}&quot;, recipient, message);
        // Actual code to send SMS using the third-party SMS service API
    }
}

// Target: SMS Service Interface
trait SMSService {
    fn send_message(&amp;self, recipient: &amp;str, message: &amp;str);
}

// Adapter: Adapts the ThirdPartySMS to the SMSService interface
struct SMSServiceAdapter {
    third_party_sms: ThirdPartySMS,
}

impl SMSService for SMSServiceAdapter {
    fn send_message(&amp;self, recipient: &amp;str, message: &amp;str) {
        self.third_party_sms.send_sms(recipient, message);
    }
}

// Client code
fn main() {
    // Create an instance of the ThirdPartySMS (Adaptee)
    let third_party_sms = ThirdPartySMS {
        api_key: &quot;API_KEY&quot;.to_owned(),
        api_secret: &quot;API_SECRET&quot;.to_owned(),
    };

    // Create an instance of the SMSServiceAdapter, wrapping the ThirdPartySMS
    let sms_service = SMSServiceAdapter {
        third_party_sms: third_party_sms,
    };

    // Call the send_message method on the SMSService
    sms_service.send_message(&quot;+123456789&quot;, &quot;Hello, world!&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bridge-pattern"><a class="header" href="#bridge-pattern">Bridge Pattern</a></h1>
<p>Separates an abstraction from its implementation, allowing them to vary independently. It helps in decoupling an abstraction from its implementation details, promoting flexibility.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<hr />
<pre><pre class="playground"><code class="language-rust">// Abstraction: Remote Control
trait RemoteControl {
    fn power_on(&amp;self);
    fn power_off(&amp;self);
    fn set_channel(&amp;self, channel: u8);
    fn next_channel(&amp;self);
    fn previous_channel(&amp;self);
}

// Implementor: TV
trait TV {
    fn power_on(&amp;self);
    fn power_off(&amp;self);
    fn set_channel(&amp;self, channel: u8);
}

// Concrete Implementor: Sony TV
struct SonyTV;

impl TV for SonyTV {
    fn power_on(&amp;self) {
        println!(&quot;Sony TV: Power ON&quot;);
    }

    fn power_off(&amp;self) {
        println!(&quot;Sony TV: Power OFF&quot;);
    }

    fn set_channel(&amp;self, channel: u8) {
        println!(&quot;Sony TV: Set Channel to {}&quot;, channel);
    }
}

// Concrete Implementor: LG TV
struct LGTV;

impl TV for LGTV {
    fn power_on(&amp;self) {
        println!(&quot;LG TV: Power ON&quot;);
    }

    fn power_off(&amp;self) {
        println!(&quot;LG TV: Power OFF&quot;);
    }

    fn set_channel(&amp;self, channel: u8) {
        println!(&quot;LG TV: Set Channel to {}&quot;, channel);
    }
}

// Refined Abstraction: Advanced Remote Control
struct AdvancedRemoteControl {
    tv: Box&lt;dyn TV&gt;,
}

impl AdvancedRemoteControl {
    fn new(tv: Box&lt;dyn TV&gt;) -&gt; Self {
        AdvancedRemoteControl { tv }
    }

    fn mute(&amp;self) {
        println!(&quot;Advanced Remote Control: Mute&quot;);
    }
}

impl RemoteControl for AdvancedRemoteControl {
    fn power_on(&amp;self) {
        self.tv.power_on();
    }

    fn power_off(&amp;self) {
        self.tv.power_off();
    }

    fn set_channel(&amp;self, channel: u8) {
        self.tv.set_channel(channel);
    }

    fn next_channel(&amp;self) {
        // Additional functionality in Advanced Remote Control
        println!(&quot;Advanced Remote Control: Next Channel&quot;);
        // Delegating to TV
        self.tv.set_channel(1);
    }

    fn previous_channel(&amp;self) {
        // Additional functionality in Advanced Remote Control
        println!(&quot;Advanced Remote Control: Previous Channel&quot;);
        // Delegating to TV
        self.tv.set_channel(1);
    }
}

// Client code
fn main() {
    // Create instances of the concrete implementors
    let sony_tv = Box::new(SonyTV);
    let lg_tv = Box::new(LGTV);

    // Use the abstraction with different implementors
    let remote1 = AdvancedRemoteControl::new(sony_tv);
    remote1.power_on();
    remote1.set_channel(5);
    remote1.mute();

    let remote2 = AdvancedRemoteControl::new(lg_tv);
    remote2.power_on();
    remote2.next_channel();
    remote2.power_off();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="composite-pattern"><a class="header" href="#composite-pattern">Composite Pattern</a></h1>
<p>Composes objects into tree structures to represent part-whole hierarchies. It treats individual objects and compositions of objects uniformly, simplifying the interaction between them.</p>
<h3 id="example-2"><a class="header" href="#example-2">Example</a></h3>
<hr />
<pre><pre class="playground"><code class="language-rust">// Define a trait for the nodes in the tree
trait Node {
    fn get_name(&amp;self) -&gt; &amp;str;
    fn add_child(&amp;mut self, child: Box&lt;dyn Node&gt;);
    fn print(&amp;self, depth: usize);
}

// Implementation of a leaf node representing a file
struct File {
    name: String,
}

impl File {
    // Create a new File node with the given name
    fn new(name: String) -&gt; Self {
        File { name }
    }
}

impl Node for File {
    // Get the name of the file
    fn get_name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }

    // Since a file cannot have children, this method does nothing
    fn add_child(&amp;mut self, _child: Box&lt;dyn Node&gt;) {
        // Files cannot have children, so this method is empty
    }

    // Print the name of the file
    fn print(&amp;self, depth: usize) {
        // Indent the output based on the depth in the tree structure
        println!(&quot;{}{}&quot;, &quot;-&quot;.repeat(depth), self.name);
    }
}

// Implementation of a composite node representing a directory
struct Directory {
    name: String,
    children: Vec&lt;Box&lt;dyn Node&gt;&gt;,
}

impl Directory {
    // Create a new Directory node with the given name
    fn new(name: String) -&gt; Self {
        Directory {
            name,
            children: Vec::new(),
        }
    }
}

impl Node for Directory {
    // Get the name of the directory
    fn get_name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }

    // Add a child node to the directory
    fn add_child(&amp;mut self, child: Box&lt;dyn Node&gt;) {
        self.children.push(child);
    }

    // Print the name of the directory and recursively print its children
    fn print(&amp;self, depth: usize) {
        // Indent the output based on the depth in the tree structure
        println!(&quot;{}{}&quot;, &quot;-&quot;.repeat(depth), self.name);

        // Recursively print the children nodes
        for child in &amp;self.children {
            child.print(depth + 1);
        }
    }
}

fn main() {
    // Create the tree structure
    let mut root = Directory::new(&quot;Root&quot;.to_string());
    let mut subdirectory1 = Directory::new(&quot;Subdirectory 1&quot;.to_string());
    let mut subdirectory2 = Directory::new(&quot;Subdirectory 2&quot;.to_string());
    let file1 = Box::new(File::new(&quot;File 1&quot;.to_string()));
    let file2 = Box::new(File::new(&quot;File 2&quot;.to_string()));
    let file3 = Box::new(File::new(&quot;File 3&quot;.to_string()));

    // Add files and subdirectories to the parent directories
    subdirectory1.add_child(file1);
    subdirectory1.add_child(file2);
    subdirectory2.add_child(file3);
    root.add_child(Box::new(subdirectory1));
    root.add_child(Box::new(subdirectory2));

    // Print the entire tree structure
    root.print(0);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="decorator-pattern"><a class="header" href="#decorator-pattern">Decorator Pattern</a></h1>
<p>Dynamically adds new behaviors or responsibilities to an object by wrapping it in a decorator class. It provides a flexible alternative to subclassing for extending functionality.</p>
<h3 id="example-3"><a class="header" href="#example-3">Example</a></h3>
<hr />
<pre><pre class="playground"><code class="language-rust">// Define a trait representing the Component interface
trait Beverage {
    fn get_description(&amp;self) -&gt; String;
    fn get_cost(&amp;self) -&gt; f64;
}

// Implementation of a concrete Component
struct Coffee;

impl Beverage for Coffee {
    fn get_description(&amp;self) -&gt; String {
        &quot;Coffee&quot;.to_string()
    }

    fn get_cost(&amp;self) -&gt; f64 {
        1.0
    }
}

// Implementation of a decorator
struct Milk {
    beverage: Box&lt;dyn Beverage&gt;,
}

impl Milk {
    fn new(beverage: Box&lt;dyn Beverage&gt;) -&gt; Self {
        Milk { beverage }
    }
}

impl Beverage for Milk {
    fn get_description(&amp;self) -&gt; String {
        format!(&quot;{} with Milk&quot;, self.beverage.get_description())
    }

    fn get_cost(&amp;self) -&gt; f64 {
        self.beverage.get_cost() + 0.5
    }
}

// Implementation of another decorator
struct Sugar {
    beverage: Box&lt;dyn Beverage&gt;,
}

impl Sugar {
    fn new(beverage: Box&lt;dyn Beverage&gt;) -&gt; Self {
        Sugar { beverage }
    }
}

impl Beverage for Sugar {
    fn get_description(&amp;self) -&gt; String {
        format!(&quot;{} with Sugar&quot;, self.beverage.get_description())
    }

    fn get_cost(&amp;self) -&gt; f64 {
        self.beverage.get_cost() + 0.25
    }
}

fn main() {
    // Create a base component
    let coffee = Box::new(Coffee);

    // Decorate the component with Milk
    let coffee_with_milk = Box::new(Milk::new(coffee));

    // Decorate the component with Sugar
    let coffee_with_milk_and_sugar = Box::new(Sugar::new(coffee_with_milk));

    // Get the final description and cost of the decorated beverage
    println!(&quot;Description: {}&quot;, coffee_with_milk_and_sugar.get_description());
    println!(&quot;Cost: ${}&quot;, coffee_with_milk_and_sugar.get_cost());
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="facade-pattern"><a class="header" href="#facade-pattern">Facade Pattern</a></h1>
<p>Provides a simplified interface to a complex subsystem, making it easier to use and understand. It hides the complexity of the underlying system and offers a unified interface.</p>
<h3 id="example-4"><a class="header" href="#example-4">Example</a></h3>
<hr />
<pre><pre class="playground"><code class="language-rust">// Subsystem 1: CPU
struct CPU;

impl CPU {
    pub fn power_on(&amp;self) {
        println!(&quot;CPU: Powering on...&quot;);
    }

    pub fn check(&amp;self) {
        println!(&quot;CPU: Checking system...&quot;);
    }

    pub fn initialize(&amp;self) {
        println!(&quot;CPU: Initializing...&quot;);
    }
}

// Subsystem 2: Memory
struct Memory;

impl Memory {
    pub fn load(&amp;self) {
        println!(&quot;Memory: Loading data...&quot;);
    }
}

// Subsystem 3: Hard Drive
struct HardDrive;

impl HardDrive {
    pub fn read(&amp;self) {
        println!(&quot;Hard Drive: Reading data...&quot;);
    }
}

// Facade: Computer
struct Computer {
    cpu: CPU,
    memory: Memory,
    hard_drive: HardDrive,
}

impl Computer {
    pub fn new() -&gt; Self {
        Computer {
            cpu: CPU {},
            memory: Memory {},
            hard_drive: HardDrive {},
        }
    }

    pub fn start(&amp;self) {
        println!(&quot;Computer: Starting up...&quot;);
        self.cpu.power_on();
        self.cpu.check();
        self.cpu.initialize();
        self.memory.load();
        self.hard_drive.read();
        println!(&quot;Computer: Startup complete!&quot;);
    }
}

// Client code
fn main() {
    let computer = Computer::new();
    computer.start();
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flyweight-pattern"><a class="header" href="#flyweight-pattern">Flyweight Pattern</a></h1>
<p>Shares common state between multiple objects to reduce memory usage. It allows for efficient representation of large numbers of fine-grained objects.</p>
<h3 id="example-5"><a class="header" href="#example-5">Example</a></h3>
<hr />
<pre><pre class="playground"><code class="language-rust">// Flyweight: UI Component
#[derive(Debug, Clone)]
struct UIComponent {
    // Shared data
    component_type: String,
    // ... other shared properties

    // Unique data
    content: String,
    // ... other unique properties
}

impl UIComponent {
    fn new(component_type: String, content: String) -&gt; Self {
        UIComponent {
            component_type,
            content,
            // initialize other properties
        }
    }

    fn render(&amp;self) {
        println!(
            &quot;Rendering {} component with content: {}&quot;,
            self.component_type, self.content
        );
        // Render the component
    }
}

// Flyweight Factory: UI Component Factory
struct UIComponentFactory {
    components: std::collections::HashMap&lt;String, Box&lt;UIComponent&gt;&gt;,
}

impl UIComponentFactory {
    fn get_component(&amp;mut self, component_type: String, content: String) -&gt; Box&lt;UIComponent&gt; {
        // Check if the component already exists in the factory
        if let Some(component) = self.components.get(&amp;component_type) {
            return component.clone();
        }

        // If not found, create a new component and add it to the factory
        let component = Box::new(UIComponent::new(component_type.clone(), content));
        self.components.insert(component_type, component.clone());
        component
    }
}

// Client code
fn main() {
    let mut component_factory = UIComponentFactory {
        components: std::collections::HashMap::new(),
    };

    // Render UI components
    let button1 = component_factory.get_component(&quot;Button&quot;.to_string(), &quot;Click me!&quot;.to_string());
    let button2 = component_factory.get_component(&quot;Button&quot;.to_string(), &quot;Submit&quot;.to_string());
    let input1 =
        component_factory.get_component(&quot;Input&quot;.to_string(), &quot;Enter your name&quot;.to_string());
    let input2 =
        component_factory.get_component(&quot;Input&quot;.to_string(), &quot;Enter your email&quot;.to_string());

    button1.render();
    button2.render();
    input1.render();
    input2.render();

    // Check if the components are the same objects
    println!(
        &quot;Are button1 and button2 the same object? {}&quot;,
        std::ptr::eq(&amp;*button1, &amp;*button2)
    );
    println!(
        &quot;Are input1 and input2 the same object? {}&quot;,
        std::ptr::eq(&amp;*input1, &amp;*input2)
    );
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proxy-pattern"><a class="header" href="#proxy-pattern">Proxy Pattern</a></h1>
<p>Provides a surrogate or placeholder for another object to control access to it. It allows for additional functionalities or restrictions to be applied to an object without changing its core implementation.</p>
<h3 id="example-6"><a class="header" href="#example-6">Example</a></h3>
<hr />
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

// Subject: Weather Service
trait WeatherService {
    fn get_temperature(&amp;mut self, city: &amp;str) -&gt; f32;
}

// Real Subject: OpenWeatherMap API
struct OpenWeatherMap {
    api_key: String,
}

impl WeatherService for OpenWeatherMap {
    fn get_temperature(&amp;mut self, city: &amp;str) -&gt; f32 {
        // Implementation to call the OpenWeatherMap API and fetch the temperature for the given city
        // This can involve making HTTP requests or any other necessary operations
        println!(
            &quot;Fetching temperature for {} from OpenWeatherMap API...&quot;,
            city
        );

        // For simplicity, let's return a placeholder value
        25.0
    }
}

// Proxy: Cached Weather Service
struct CachedWeatherService {
    weather_service: OpenWeatherMap,
    cache: HashMap&lt;String, f32&gt;,
}

impl CachedWeatherService {
    fn new(weather_service: OpenWeatherMap) -&gt; Self {
        CachedWeatherService {
            weather_service,
            cache: HashMap::new(),
        }
    }
}

impl WeatherService for CachedWeatherService {
    fn get_temperature(&amp;mut self, city: &amp;str) -&gt; f32 {
        // Check if the temperature is available in the cache
        if let Some(&amp;temperature) = self.cache.get(city) {
            println!(&quot;Retrieving temperature for {} from cache...&quot;, city);
            return temperature;
        }

        // If not found in cache, fetch the temperature using the real weather service
        let temperature = self.weather_service.get_temperature(city);
        println!(
            &quot;Retrieving temperature for {} from weather service...&quot;,
            city
        );

        // Store the temperature in the cache for future use
        self.cache.insert(city.to_string(), temperature);

        temperature
    }
}

// Client code
fn main() {
    // Create the real weather service and wrap it with the cached proxy
    let weather_service = OpenWeatherMap {
        api_key: &quot;YOUR_API_KEY&quot;.to_string(),
    };
    let mut cached_weather_service = CachedWeatherService::new(weather_service);

    // Access the temperature using the cached proxy
    let city = &quot;London&quot;;
    let temperature1 = cached_weather_service.get_temperature(city);
    let temperature2 = cached_weather_service.get_temperature(city);

    println!(
        &quot;Temperature in {} is {} degrees Celsius&quot;,
        city, temperature1
    );
    println!(&quot;Retrieved temperature from cache: {}&quot;, temperature2);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="behavioral-design-patterns"><a class="header" href="#behavioral-design-patterns">Behavioral Design Patterns</a></h1>
<p>Behavioral design patterns focus on the interaction and communication between objects, providing solutions for effectively managing complex behaviors and relationships. These patterns emphasize the collaboration and coordination between objects to achieve specific functionalities, such as defining communication protocols, encapsulating algorithms, or handling varying behaviors. They help in designing flexible and maintainable systems by promoting loose coupling, reusability, and extensibility.</p>
<h2 id="common-behavioral-design-patterns"><a class="header" href="#common-behavioral-design-patterns">Common Behavioral Design Patterns</a></h2>
<p>Here are some common behavioral design patterns:</p>
<ol>
<li>
<p><span class="usecase-heading">Observer Pattern</span>: Allows objects to subscribe and receive updates from a subject when its state changes, enabling loose coupling between the subject and observers.</p>
</li>
<li>
<p><span class="usecase-heading">State Pattern</span>: Enables an object to alter its behavior when its internal state changes, encapsulating different states as separate classes and allowing for easy state transitions.</p>
</li>
<li>
<p><span class="usecase-heading">Strategy Pattern</span>: Defines a family of interchangeable algorithms and encapsulates each algorithm separately, allowing them to be used interchangeably based on specific requirements.</p>
</li>
<li>
<p><span class="usecase-heading">Command Pattern</span>: Encapsulates a request as an object, allowing parameterization of clients with different requests, queuing or logging requests, and supporting undoable operations.</p>
</li>
<li>
<p><span class="usecase-heading">Visitor Pattern</span>: Separates the algorithm from the objects it operates on, allowing new operations to be added to the object structure without modifying the objects themselves.</p>
</li>
<li>
<p><span class="usecase-heading">Iterator Pattern</span>: Provides a way to sequentially access elements of an aggregate object without exposing its underlying representation, allowing iteration over various data structures.</p>
</li>
<li>
<p><span class="usecase-heading">Chain of Responsibility Pattern</span>: Decouples the sender of a request from its receivers, forming a chain of objects that can handle the request dynamically, giving each receiver the chance to process the request or pass it to the next receiver.</p>
</li>
<li>
<p><span class="usecase-heading">Mediator Pattern</span>: Defines an object that encapsulates how a set of objects interact, promoting loose coupling between objects by centralizing their communication through the mediator.</p>
</li>
<li>
<p><span class="usecase-heading">Memento Pattern</span>: The Memento pattern allows an object to capture its internal state and store it externally, without violating encapsulation. It provides the ability to restore the object's state to a previous state.</p>
</li>
<li>
<p><span class="usecase-heading">Interpreter Pattern</span>: Defines a representation of grammar and an interpreter to evaluate sentences in the language, enabling the interpretation of a language or expression.</p>
</li>
<li>
<p><span class="usecase-heading">Template Pattern</span>: Defines the skeleton of an algorithm in a base class and allows subclasses to override specific steps of the algorithm while keeping the overall structure intact.</p>
</li>
</ol>
<p>These patterns provide solutions to common challenges in managing behaviors, interactions, and communication between objects, promoting flexibility, extensibility, and maintainability in software systems.</p>
<h2 id="benefits-of-behavioral-design-patterns"><a class="header" href="#benefits-of-behavioral-design-patterns">Benefits of Behavioral Design Patterns</a></h2>
<p>Here are some benefits of using behavioral design patterns:</p>
<ul>
<li>
<p><strong>Modularity and Reusability</strong>: Behavioral design patterns promote modular design by encapsulating specific behaviors into separate objects or classes. This allows for better code organization and enhances reusability, as the same behavior can be applied in different contexts.</p>
</li>
<li>
<p><strong>Flexibility and Extensibility</strong>: Behavioral design patterns provide a flexible and extensible approach to software design. They allow behaviors to be easily modified or extended without affecting other parts of the codebase, promoting adaptability to changing requirements.</p>
</li>
<li>
<p><strong>Loose Coupling</strong>: Behavioral design patterns promote loose coupling between objects by focusing on interactions between them rather than their concrete implementations. This enhances maintainability and testability, as objects can be replaced or modified without affecting the overall system.</p>
</li>
<li>
<p><strong>Code Readability</strong>: Behavioral design patterns often follow established conventions and best practices, making the code more readable and understandable. They provide a common language and structure for solving specific behavioral problems, making the codebase more cohesive and easier to comprehend.</p>
</li>
<li>
<p><strong>Separation of Concerns</strong>: Behavioral design patterns help separate different concerns and responsibilities in a system, making it easier to manage and maintain. Each pattern addresses a specific aspect of behavior, allowing developers to focus on individual concerns without introducing unnecessary complexity.</p>
</li>
<li>
<p><strong>Code Organization</strong>: Behavioral design patterns provide a systematic approach to organizing code related to behavior. They offer clear guidelines on where to place behavior-related logic and how to structure interactions between objects, resulting in a more organized and maintainable codebase.</p>
</li>
</ul>
<p>By leveraging these benefits, behavioral design patterns can enhance the overall design, flexibility, and maintainability of your software system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="observer-pattern"><a class="header" href="#observer-pattern">Observer Pattern</a></h1>
<p>Allows objects to subscribe and receive updates from a subject when its state changes, enabling loose coupling between the subject and observers</p>
<h3 id="example-7"><a class="header" href="#example-7">Example</a></h3>
<hr />
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::{Rc, Weak};

// Subject or Publisher
struct Marketplace {
    subscribers: Vec&lt;Weak&lt;Customer&gt;&gt;,
}

impl Marketplace {
    fn new() -&gt; Self {
        Marketplace {
            subscribers: Vec::new(),
        }
    }

    fn subscribe(&amp;mut self, customer: Rc&lt;Customer&gt;) {
        self.subscribers.push(Rc::downgrade(&amp;customer));
    }

    fn notify_subscribers(&amp;self, product: &amp;str) {
        for subscriber in &amp;self.subscribers {
            if let Some(customer) = subscriber.upgrade() {
                customer.notify(product);
            }
        }
    }
}

// Observer or Subscriber
struct Customer {
    name: String,
}

impl Customer {
    fn new(name: &amp;str) -&gt; Self {
        Customer {
            name: name.to_string(),
        }
    }

    fn notify(&amp;self, product: &amp;str) {
        println!(&quot;Hey {}, the product {} is now available!&quot;, self.name, product);
    }
}

fn main() {
    let mut marketplace = Marketplace::new();

    let customer1 = Rc::new(Customer::new(&quot;John&quot;));
    let customer2 = Rc::new(Customer::new(&quot;Alice&quot;));

    marketplace.subscribe(customer1.clone());
    marketplace.subscribe(customer2.clone());

    marketplace.notify_subscribers(&quot;Phone&quot;);

    // Output:
    // Hey John, the product Phone is now available!
    // Hey Alice, the product Phone is now available!
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="state-pattern"><a class="header" href="#state-pattern">State Pattern</a></h1>
<p>Enables an object to alter its behavior when its internal state changes, encapsulating different states as separate classes and allowing for easy state transitions.</p>
<h3 id="example-8"><a class="header" href="#example-8">Example</a></h3>
<hr />
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::rc::Rc;

// State trait
trait State {
    fn handle(self: Rc&lt;Self&gt;, context: &amp;mut WorkflowContext);
}

// Concrete states
struct DraftState;
struct ReviewState;
struct ApprovedState;
struct PublishedState;

impl State for DraftState {
    fn handle(self: Rc&lt;Self&gt;, context: &amp;mut WorkflowContext) {
        // Perform actions specific to the Draft state
        println!(&quot;Workflow is in the Draft state.&quot;);
        println!(&quot;Performing actions for Draft state...&quot;);

        // Transition to the next state
        context.set_state(Rc::new(ReviewState {}));
    }
}

impl State for ReviewState {
    fn handle(self: Rc&lt;Self&gt;, context: &amp;mut WorkflowContext) {
        // Perform actions specific to the Review state
        println!(&quot;Workflow is in the Review state.&quot;);
        println!(&quot;Performing actions for Review state...&quot;);

        // Transition to the next state
        context.set_state(Rc::new(ApprovedState {}));
    }
}

impl State for ApprovedState {
    fn handle(self: Rc&lt;Self&gt;, context: &amp;mut WorkflowContext) {
        // Perform actions specific to the Approved state
        println!(&quot;Workflow is in the Approved state.&quot;);
        println!(&quot;Performing actions for Approved state...&quot;);

        // Transition to the next state
        context.set_state(Rc::new(PublishedState {}));
    }
}

impl State for PublishedState {
    fn handle(self: Rc&lt;Self&gt;, context: &amp;mut WorkflowContext) {
        // Perform actions specific to the Published state
        println!(&quot;Workflow is in the Published state.&quot;);
        println!(&quot;Performing actions for Published state...&quot;);

        // No further state transition from the Published state
        println!(&quot;Workflow is in its final state.&quot;);
    }
}

// Context that holds the state and manages state transitions
struct WorkflowContext {
    state: Rc&lt;dyn State&gt;,
}

impl WorkflowContext {
    fn new(state: Rc&lt;dyn State&gt;) -&gt; Self {
        WorkflowContext { state }
    }

    fn set_state(&amp;mut self, state: Rc&lt;dyn State&gt;) {
        self.state = state;
    }

    fn perform_workflow(&amp;mut self) {
        // Call the handle method on the current state
        self.state.clone().handle(self);
    }
}

// Client code
fn main() {
    let initial_state = Rc::new(DraftState {});
    let mut workflow = WorkflowContext::new(initial_state);

    // Perform the workflow
    workflow.perform_workflow();

    // The workflow can be triggered again to transition to the next state
    workflow.perform_workflow();

    // Trigger the workflow multiple times to reach the final state
    workflow.perform_workflow();
    workflow.perform_workflow();
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strategy-pattern"><a class="header" href="#strategy-pattern">Strategy Pattern</a></h1>
<p>Defines a family of interchangeable algorithms and encapsulates each algorithm separately, allowing them to be used interchangeably based on specific requirements.</p>
<h3 id="example-9"><a class="header" href="#example-9">Example</a></h3>
<hr />
<pre><pre class="playground"><code class="language-rust">// Payment Strategy trait
trait PaymentStrategy {
    fn process_payment(&amp;self, amount: f64);
}

// Credit Card Payment Strategy
struct CreditCardPaymentStrategy {
    card_number: String,
    expiration_date: String,
    cvv: String,
}

impl PaymentStrategy for CreditCardPaymentStrategy {
    fn process_payment(&amp;self, amount: f64) {
        println!(&quot;Processing credit card payment of {} USD&quot;, amount);
        // Logic to process payment with credit card
    }
}

// PayPal Payment Strategy
struct PayPalPaymentStrategy {
    email: String,
    password: String,
}

impl PaymentStrategy for PayPalPaymentStrategy {
    fn process_payment(&amp;self, amount: f64) {
        println!(&quot;Processing PayPal payment of {} USD&quot;, amount);
        // Logic to process payment with PayPal
    }
}

// Bank Transfer Payment Strategy
struct BankTransferPaymentStrategy {
    account_number: String,
    routing_number: String,
}

impl PaymentStrategy for BankTransferPaymentStrategy {
    fn process_payment(&amp;self, amount: f64) {
        println!(&quot;Processing bank transfer payment of {} USD&quot;, amount);
        // Logic to process payment with bank transfer
    }
}

// Payment Context
struct PaymentContext {
    payment_strategy: Box&lt;dyn PaymentStrategy&gt;,
}

impl PaymentContext {
    fn new(payment_strategy: Box&lt;dyn PaymentStrategy&gt;) -&gt; Self {
        PaymentContext { payment_strategy }
    }

    fn process_payment(&amp;self, amount: f64) {
        self.payment_strategy.process_payment(amount);
    }
}

fn main() {
    let credit_card_strategy = Box::new(CreditCardPaymentStrategy {
        card_number: &quot;1234 5678 9012 3456&quot;.to_string(),
        expiration_date: &quot;12/23&quot;.to_string(),
        cvv: &quot;123&quot;.to_string(),
    });

    let paypal_strategy = Box::new(PayPalPaymentStrategy {
        email: &quot;user@example.com&quot;.to_string(),
        password: &quot;password123&quot;.to_string(),
    });

    let bank_transfer_strategy = Box::new(BankTransferPaymentStrategy {
        account_number: &quot;123456789&quot;.to_string(),
        routing_number: &quot;987654321&quot;.to_string(),
    });

    let payment_amount = 100.00;

    let credit_card_context = PaymentContext::new(credit_card_strategy);
    credit_card_context.process_payment(payment_amount);

    let paypal_context = PaymentContext::new(paypal_strategy);
    paypal_context.process_payment(payment_amount);

    let bank_transfer_context = PaymentContext::new(bank_transfer_strategy);
    bank_transfer_context.process_payment(payment_amount);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-pattern"><a class="header" href="#command-pattern">Command Pattern</a></h1>
<p>Encapsulates a request as an object, allowing parameterization of clients with different requests, queuing or logging requests, and supporting undoable operations.</p>
<h3 id="example-10"><a class="header" href="#example-10">Example</a></h3>
<hr />
<pre><pre class="playground"><code class="language-rust">// Device trait
trait Device {
    fn on(&amp;self);
    fn off(&amp;self);
}

// Light device
struct Light {
    name: String,
}

impl Device for Light {
    fn on(&amp;self) {
        println!(&quot;{} light turned on&quot;, self.name);
        // Logic to turn on the light
    }

    fn off(&amp;self) {
        println!(&quot;{} light turned off&quot;, self.name);
        // Logic to turn off the light
    }
}

// Thermostat device
struct Thermostat {
    name: String,
}

impl Device for Thermostat {
    fn on(&amp;self) {
        println!(&quot;{} thermostat turned on&quot;, self.name);
        // Logic to turn on the thermostat
    }

    fn off(&amp;self) {
        println!(&quot;{} thermostat turned off&quot;, self.name);
        // Logic to turn off the thermostat
    }
}

// Command trait
trait Command {
    fn execute(&amp;self);
    fn undo(&amp;self);
}

// Concrete command for turning on the device
struct TurnOnCommand&lt;T: Device&gt; {
    device: T,
}

impl&lt;T: Device&gt; Command for TurnOnCommand&lt;T&gt; {
    fn execute(&amp;self) {
        self.device.on();
    }

    fn undo(&amp;self) {
        self.device.off();
    }
}

// Concrete command for turning off the device
struct TurnOffCommand&lt;T: Device&gt; {
    device: T,
}

impl&lt;T: Device&gt; Command for TurnOffCommand&lt;T&gt; {
    fn execute(&amp;self) {
        self.device.off();
    }

    fn undo(&amp;self) {
        self.device.on();
    }
}

// Home automation system
struct HomeAutomation {
    commands: Vec&lt;Box&lt;dyn Command&gt;&gt;,
}

impl HomeAutomation {
    fn new() -&gt; Self {
        HomeAutomation {
            commands: Vec::new(),
        }
    }

    fn add_command(&amp;mut self, command: Box&lt;dyn Command&gt;) {
        self.commands.push(command);
    }

    fn execute_commands(&amp;self) {
        for command in &amp;self.commands {
            command.execute();
        }
    }

    fn undo_commands(&amp;self) {
        for command in self.commands.iter().rev() {
            command.undo();
        }
    }
}

fn main() {
    let living_room_light = Light {
        name: &quot;Living Room Light&quot;.to_string(),
    };
    let bedroom_light = Light {
        name: &quot;Bedroom Light&quot;.to_string(),
    };
    let thermostat = Thermostat {
        name: &quot;Thermostat&quot;.to_string(),
    };

    let turn_on_living_room_light = Box::new(TurnOnCommand {
        device: living_room_light,
    });
    let turn_off_bedroom_light = Box::new(TurnOffCommand {
        device: bedroom_light,
    });
    let turn_on_thermostat = Box::new(TurnOnCommand { device: thermostat });

    let mut home_automation = HomeAutomation::new();
    home_automation.add_command(turn_on_living_room_light);
    home_automation.add_command(turn_off_bedroom_light);
    home_automation.add_command(turn_on_thermostat);

    home_automation.execute_commands();
    println!(&quot;Undoing last command:&quot;);
    home_automation.undo_commands();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="visitor-pattern"><a class="header" href="#visitor-pattern">Visitor Pattern</a></h1>
<p>Separates the algorithm from the objects it operates on, allowing new operations to be added to the object structure without modifying the objects themselves.</p>
<h3 id="example-11"><a class="header" href="#example-11">Example</a></h3>
<hr />
<pre><pre class="playground"><code class="language-rust">// Node trait representing a node in the tree
trait Node {
    fn accept(&amp;self, visitor: &amp;mut dyn Visitor);
}

// Leaf node in the tree
struct LeafNode {
    value: i32,
}

impl Node for LeafNode {
    fn accept(&amp;self, visitor: &amp;mut dyn Visitor) {
        visitor.visit_leaf_node(self);
    }
}

// Composite node in the tree
struct CompositeNode {
    children: Vec&lt;Box&lt;dyn Node&gt;&gt;,
}

impl Node for CompositeNode {
    fn accept(&amp;self, visitor: &amp;mut dyn Visitor) {
        visitor.visit_composite_node(self);
    }
}

// Visitor trait defining the operations to be performed on nodes
trait Visitor {
    fn visit_leaf_node(&amp;mut self, node: &amp;LeafNode);
    fn visit_composite_node(&amp;mut self, node: &amp;CompositeNode);
}

// Concrete visitor implementation
struct SumVisitor {
    sum: i32,
}

impl SumVisitor {
    fn new() -&gt; Self {
        SumVisitor { sum: 0 }
    }
}

impl Visitor for SumVisitor {
    fn visit_leaf_node(&amp;mut self, node: &amp;LeafNode) {
        self.sum += node.value;
    }

    fn visit_composite_node(&amp;mut self, node: &amp;CompositeNode) {
        for child in &amp;node.children {
            child.accept(self);
        }
    }
}

fn main() {
    // Create the tree structure
    let leaf1 = Box::new(LeafNode { value: 5 });
    let leaf2 = Box::new(LeafNode { value: 10 });
    let composite1 = Box::new(CompositeNode {
        children: vec![leaf1, leaf2],
    });

    let leaf3 = Box::new(LeafNode { value: 15 });
    let leaf4 = Box::new(LeafNode { value: 20 });
    let composite2 = Box::new(CompositeNode {
        children: vec![leaf3, leaf4],
    });

    let root = Box::new(CompositeNode {
        children: vec![composite1, composite2],
    });

    // Create the visitor and perform the operations on the tree
    let mut sum_visitor = SumVisitor::new();
    root.accept(&amp;mut sum_visitor);

    println!(&quot;Sum of all leaf node values: {}&quot;, sum_visitor.sum);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterator-pattern"><a class="header" href="#iterator-pattern">Iterator Pattern</a></h1>
<p>Provides a way to sequentially access elements of an aggregate object without exposing its underlying representation, allowing iteration over various data structures.</p>
<h2 id="example-12"><a class="header" href="#example-12">Example</a></h2>
<hr />
<pre><pre class="playground"><code class="language-rust">// Song struct
struct Song {
    title: String,
    artist: String,
    duration: u32,
}

// Music Collection
struct MusicCollection {
    songs: Vec&lt;Song&gt;,
}

impl MusicCollection {
    fn new() -&gt; Self {
        MusicCollection { songs: Vec::new() }
    }

    fn add_song(&amp;mut self, song: Song) {
        self.songs.push(song);
    }

    fn iter(&amp;self) -&gt; MusicIterator {
        MusicIterator::new(&amp;self.songs)
    }
}

// Iterator for Music Collection
struct MusicIterator&lt;'a&gt; {
    songs: &amp;'a Vec&lt;Song&gt;,
    current_index: usize,
}

impl&lt;'a&gt; MusicIterator&lt;'a&gt; {
    fn new(songs: &amp;'a Vec&lt;Song&gt;) -&gt; Self {
        MusicIterator {
            songs,
            current_index: 0,
        }
    }
}

impl&lt;'a&gt; Iterator for MusicIterator&lt;'a&gt; {
    type Item = &amp;'a Song;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.current_index &lt; self.songs.len() {
            let song = &amp;self.songs[self.current_index];
            self.current_index += 1;
            Some(song)
        } else {
            None
        }
    }
}

fn main() {
    let mut music_collection = MusicCollection::new();

    // Add songs to the music collection
    music_collection.add_song(Song {
        title: &quot;Song 1&quot;.to_string(),
        artist: &quot;Artist 1&quot;.to_string(),
        duration: 180,
    });
    music_collection.add_song(Song {
        title: &quot;Song 2&quot;.to_string(),
        artist: &quot;Artist 2&quot;.to_string(),
        duration: 240,
    });
    music_collection.add_song(Song {
        title: &quot;Song 3&quot;.to_string(),
        artist: &quot;Artist 3&quot;.to_string(),
        duration: 210,
    });

    // Iterate over the songs in the music collection
    for song in music_collection.iter() {
        println!(&quot;Title: {}&quot;, song.title);
        println!(&quot;Artist: {}&quot;, song.artist);
        println!(&quot;Duration: {} seconds&quot;, song.duration);
        println!(&quot;-----------------------&quot;);
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chain-of-responsibility-pattern"><a class="header" href="#chain-of-responsibility-pattern">Chain of Responsibility Pattern</a></h1>
<p>Decouples the sender of a request from its receivers, forming a chain of objects that can handle the request dynamically, giving each receiver the chance to process the request or pass it to the next receiver.</p>
<h3 id="example-13"><a class="header" href="#example-13">Example</a></h3>
<hr />
<pre><pre class="playground"><code class="language-rust">struct Request {
    path: String,
    method: String,
}

trait Middleware {
    fn handle_request(&amp;self, request: &amp;Request) -&gt; Option&lt;String&gt;;
}

struct AuthenticationMiddleware {
    next: Option&lt;Box&lt;dyn Middleware&gt;&gt;,
}

impl Middleware for AuthenticationMiddleware {
    fn handle_request(&amp;self, request: &amp;Request) -&gt; Option&lt;String&gt; {
        // Perform authentication logic here
        println!(&quot;Authentication middleware: Authenticating request...&quot;);

        // If authentication succeeds, pass the request to the next middleware
        self.next.as_ref().and_then(|middleware| middleware.handle_request(request))
    }
}

struct LoggingMiddleware {
    next: Option&lt;Box&lt;dyn Middleware&gt;&gt;,
}

impl Middleware for LoggingMiddleware {
    fn handle_request(&amp;self, request: &amp;Request) -&gt; Option&lt;String&gt; {
        // Perform logging logic here
        println!(&quot;Logging middleware: Logging request - path: {}, method: {}&quot;, request.path, request.method);

        // Pass the request to the next middleware
        self.next.as_ref().and_then(|middleware| middleware.handle_request(request))
    }
}

struct AuthorizationMiddleware {
    next: Option&lt;Box&lt;dyn Middleware&gt;&gt;,
}

impl Middleware for AuthorizationMiddleware {
    fn handle_request(&amp;self, request: &amp;Request) -&gt; Option&lt;String&gt; {
        // Perform authorization logic here
        println!(&quot;Authorization middleware: Authorizing request...&quot;);

        // If authorization succeeds, pass the request to the next middleware
        self.next.as_ref().and_then(|middleware| middleware.handle_request(request))
    }
}

struct RequestHandler {
    middleware: Option&lt;Box&lt;dyn Middleware&gt;&gt;,
}

impl RequestHandler {
    fn handle_request(&amp;self, request: Request) -&gt; Option&lt;String&gt; {
        self.middleware.as_ref().and_then(|middleware| middleware.handle_request(&amp;request))
    }
}

fn main() {
    // Create the chain of middleware
    let authentication_middleware = AuthenticationMiddleware { next: None };
    let logging_middleware = LoggingMiddleware { next: Some(Box::new(authentication_middleware)) };
    let authorization_middleware = AuthorizationMiddleware { next: Some(Box::new(logging_middleware)) };

    // Create the request handler
    let request_handler = RequestHandler { middleware: Some(Box::new(authorization_middleware)) };

    // Handle a sample request
    let request = Request { path: &quot;/api/users&quot;.to_string(), method: &quot;GET&quot;.to_string() };
    let response = request_handler.handle_request(request);

    // Process the response, e.g., send it back to the client
    println!(&quot;Response: {:?}&quot;, response);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mediator-pattern"><a class="header" href="#mediator-pattern">Mediator Pattern</a></h1>
<p>Defines an object that encapsulates how a set of objects interact, promoting loose coupling between objects by centralizing their communication through the mediator.</p>
<h3 id="examples-4"><a class="header" href="#examples-4">Examples</a></h3>
<hr />
<pre><pre class="playground"><code class="language-rust">use std::cell::RefCell;
use std::collections::HashMap;
use std::rc::Rc;

// Mediator: ChatRoom
// The ChatRoom acts as the central mediator that facilitates communication between users.

struct ChatRoom {
    users: HashMap&lt;String, Rc&lt;RefCell&lt;User&gt;&gt;&gt;, // Stores the users in the chat room
    public_messages: Vec&lt;(String, String)&gt;,    // Stores public messages
}

impl ChatRoom {
    fn new() -&gt; Self {
        ChatRoom {
            users: HashMap::new(),
            public_messages: Vec::new(),
        }
    }

    // Mediator: add_user
    // Adds a user to the chat room and registers them in the users' HashMap.

    fn add_user(&amp;mut self, user: Rc&lt;RefCell&lt;User&gt;&gt;) {
        let username = user.borrow().username.clone();
        self.users.insert(username, user);
    }

    // Mediator: send_message
    // Sends a message from a sender to a recipient in the chat room.
    // If the recipient is &quot;public&quot;, the message is stored as a public message.
    // Otherwise, the message is sent to the recipient's User object.

    fn send_message(&amp;mut self, sender: &amp;str, recipient: &amp;str, message: &amp;str) {
        if recipient == &quot;public&quot; {
            self.public_messages
                .push((sender.to_string(), message.to_string()));
        } else if let Some(user) = self.users.get(recipient) {
            user.borrow().receive_message(sender, message);
        }
    }

    // Mediator: broadcast_message
    // Sends a message from a sender to all users in the chat room.

    fn broadcast_message(&amp;self, sender: &amp;str, message: &amp;str) {
        for user in self.users.values() {
            user.borrow().receive_message(sender, message);
        }
    }
}

// Colleague: User
// The User represents a participant in the chat room who can send and receive messages.

struct User {
    username: String,
    chat_room: Rc&lt;RefCell&lt;ChatRoom&gt;&gt;, // Reference to the ChatRoom mediator
}

impl User {
    fn new(username: String, chat_room: Rc&lt;RefCell&lt;ChatRoom&gt;&gt;) -&gt; Self {
        User {
            username,
            chat_room,
        }
    }

    // Colleague: send_message
    // Sends a message from the user to a recipient using the ChatRoom mediator.

    fn send_message(&amp;mut self, recipient: &amp;str, message: &amp;str) {
        self.chat_room
            .borrow_mut()
            .send_message(&amp;self.username, recipient, message);
    }

    // Colleague: receive_message
    // Receives a message from a sender and displays it on the user's console.

    fn receive_message(&amp;self, sender: &amp;str, message: &amp;str) {
        println!(
            &quot;{} received a message from {}: {}&quot;,
            self.username, sender, message
        );
    }
}

fn main() {
    let chat_room = Rc::new(RefCell::new(ChatRoom::new()));

    let user1 = Rc::new(RefCell::new(User::new(
        &quot;John&quot;.to_string(),
        Rc::clone(&amp;chat_room),
    )));
    let user2 = Rc::new(RefCell::new(User::new(
        &quot;Emily&quot;.to_string(),
        Rc::clone(&amp;chat_room),
    )));
    let user3 = Rc::new(RefCell::new(User::new(
        &quot;Michael&quot;.to_string(),
        Rc::clone(&amp;chat_room),
    )));

    chat_room.borrow_mut().add_user(Rc::clone(&amp;user1));
    chat_room.borrow_mut().add_user(Rc::clone(&amp;user2));
    chat_room.borrow_mut().add_user(Rc::clone(&amp;user3));

    user1
        .borrow_mut()
        .send_message(&quot;Emily&quot;, &quot;Hi Emily! How are you?&quot;);
    user2
        .borrow_mut()
        .send_message(&quot;Michael&quot;, &quot;Hey Michael, did you see John's message?&quot;);
    user3
        .borrow_mut()
        .send_message(&quot;John&quot;, &quot;Yes, I did. Let's continue the conversation.&quot;);
    user1
        .borrow_mut()
        .send_message(&quot;public&quot;, &quot;This is a public message.&quot;);
    chat_room
        .borrow()
        .broadcast_message(&quot;Admin&quot;, &quot;Attention: New event coming up!&quot;);

    // Output:
    // Emily received a message from John: Hi Emily! How are you?
    // Michael received a message from Emily: Hey Michael, did you see John's message?
    // John received a message from Michael: Yes, I did. Let's continue the conversation.
    // Emily received a message from Admin: Attention: New event coming up!
    // Michael received a message from Admin: Attention: New event coming up!
    // John received a message from Admin: Attention: New event coming up!
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memento-pattern"><a class="header" href="#memento-pattern">Memento Pattern</a></h1>
<p>The Memento pattern allows an object to capture its internal state and store it externally, without violating encapsulation. It provides the ability to restore the object's state to a previous state.</p>
<h3 id="example-14"><a class="header" href="#example-14">Example</a></h3>
<hr />
<pre><pre class="playground"><code class="language-rust">struct TextEditor {
    text: String,
    cursor_position: usize,
    undo_stack: Vec&lt;TextEditorMemento&gt;,
}

impl TextEditor {
    fn new() -&gt; Self {
        TextEditor {
            text: String::new(),
            cursor_position: 0,
            undo_stack: Vec::new(),
        }
    }

    fn insert_text(&amp;mut self, text: &amp;str) {
        self.text.insert_str(self.cursor_position, text);
        self.cursor_position += text.len();
    }

    fn move_cursor_left(&amp;mut self) {
        if self.cursor_position &gt; 0 {
            self.cursor_position -= 1;
        }
    }

    fn move_cursor_right(&amp;mut self) {
        if self.cursor_position &lt; self.text.len() {
            self.cursor_position += 1;
        }
    }

    fn undo(&amp;mut self) {
        if let Some(memento) = self.undo_stack.pop() {
            self.text = memento.text;
            self.cursor_position = memento.cursor_position;
        }
    }

    fn save_undo_state(&amp;mut self) {
        let memento = TextEditorMemento {
            text: self.text.clone(),
            cursor_position: self.cursor_position,
        };
        self.undo_stack.push(memento);
    }

    fn display(&amp;self) {
        println!(&quot;Text: {}&quot;, self.text);
        println!(
            &quot;Cursor Position: {}&quot;,
            &quot; &quot;.repeat(self.cursor_position) + &quot;^&quot;
        );
    }
}

struct TextEditorMemento {
    text: String,
    cursor_position: usize,
}

fn main() {
    let mut editor = TextEditor::new();

    editor.insert_text(&quot;Hello&quot;);
    editor.display(); // Text: Hello, Cursor Position: ^

    editor.save_undo_state();

    editor.insert_text(&quot; World&quot;);
    editor.display(); // Text: Hello World, Cursor Position: ^

    editor.save_undo_state();

    editor.move_cursor_left();
    editor.display(); // Text: Hello World, Cursor Position: ^

    editor.undo();
    editor.display(); // Text: Hello World, Cursor Position: ^

    editor.undo();
    editor.display(); // Text: Hello, Cursor Position: ^
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interpreter-pattern"><a class="header" href="#interpreter-pattern">Interpreter Pattern</a></h1>
<p>Defines a representation of grammar and an interpreter to evaluate sentences in the language, enabling the interpretation of a language or expression.</p>
<h3 id="example-15"><a class="header" href="#example-15">Example</a></h3>
<hr />
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

trait Expression {
    fn interpret(&amp;self, context: &amp;Context) -&gt; i32;
}

struct NumberExpression {
    value: i32,
}

impl NumberExpression {
    fn new(value: i32) -&gt; Self {
        NumberExpression { value }
    }
}

impl Expression for NumberExpression {
    fn interpret(&amp;self, _context: &amp;Context) -&gt; i32 {
        self.value
    }
}

struct AddExpression {
    left: Box&lt;dyn Expression&gt;,
    right: Box&lt;dyn Expression&gt;,
}

impl AddExpression {
    fn new(left: Box&lt;dyn Expression&gt;, right: Box&lt;dyn Expression&gt;) -&gt; Self {
        AddExpression { left, right }
    }
}

impl Expression for AddExpression {
    fn interpret(&amp;self, context: &amp;Context) -&gt; i32 {
        self.left.interpret(context) + self.right.interpret(context)
    }
}

struct Context {
    variables: HashMap&lt;String, i32&gt;,
}

impl Context {
    fn new() -&gt; Self {
        Context {
            variables: HashMap::new(),
        }
    }

    fn set_variable(&amp;mut self, name: &amp;str, value: i32) {
        self.variables.insert(name.to_string(), value);
    }

    fn get_variable(&amp;self, name: &amp;str) -&gt; Option&lt;&amp;i32&gt; {
        self.variables.get(name)
    }
}

fn main() {
    let mut context = Context::new();
    context.set_variable(&quot;x&quot;, 5);
    context.set_variable(&quot;y&quot;, 3);

    let expression = AddExpression::new(
        Box::new(NumberExpression::new(2)),
        Box::new(AddExpression::new(
            Box::new(NumberExpression::new(3)),
            Box::new(NumberExpression::new(4)),
        )),
    );

    let result = expression.interpret(&amp;context);
    println!(&quot;Result: {}&quot;, result);
}

</code></pre></pre>
<p><strong>Regular Expression</strong></p>
<pre><pre class="playground"><code class="language-rust">trait Regex {
    fn matches(&amp;self, input: &amp;str) -&gt; bool;
}

struct EmailRegex {
    pattern: String,
}

impl EmailRegex {
    fn new(pattern: &amp;str) -&gt; Self {
        EmailRegex {
            pattern: pattern.to_string(),
        }
    }
}

impl Regex for EmailRegex {
    fn matches(&amp;self, input: &amp;str) -&gt; bool {
        // Perform pattern matching logic based on the email regex pattern
        // Here, we'll assume a simplified implementation for demonstration purposes
        input.contains(&amp;self.pattern)
    }
}

fn main() {
    let email_regex = EmailRegex::new(r&quot;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$&quot;);

    let email = &quot;test@example.com&quot;;
    let is_valid = email_regex.matches(email);

    if is_valid {
        println!(&quot;The email is valid!&quot;);
    } else {
        println!(&quot;Invalid email.&quot;);
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="template-pattern"><a class="header" href="#template-pattern">Template Pattern</a></h1>
<p>Defines the skeleton of an algorithm in a base class and allows subclasses to override specific steps of the algorithm while keeping the overall structure intact.</p>
<h3 id="example-16"><a class="header" href="#example-16">Example</a></h3>
<hr />
<pre><pre class="playground"><code class="language-rust">// Abstract Recipe
trait Recipe {
    fn prepare_ingredients(&amp;self);
    fn cook(&amp;self);
    fn serve(&amp;self);

    fn make_recipe(&amp;self) {
        self.prepare_ingredients();
        self.cook();
        self.serve();
    }
}

// Concrete Recipe: Pasta Carbonara
struct PastaCarbonara;

impl Recipe for PastaCarbonara {
    fn prepare_ingredients(&amp;self) {
        println!(&quot;Gather ingredients for Pasta Carbonara&quot;);
        println!(&quot;Boil water and cook pasta&quot;);
        println!(&quot;Chop bacon and garlic&quot;);
    }

    fn cook(&amp;self) {
        println!(&quot;Cook bacon and garlic in a pan&quot;);
        println!(&quot;Mix cooked pasta with bacon and garlic&quot;);
        println!(&quot;Whisk eggs and Parmesan cheese&quot;);
        println!(&quot;Combine egg mixture with pasta&quot;);
        println!(&quot;Heat the mixture to create a creamy sauce&quot;);
    }

    fn serve(&amp;self) {
        println!(&quot;Serve Pasta Carbonara with additional Parmesan cheese&quot;);
        println!(&quot;Enjoy!&quot;);
    }
}

// Concrete Recipe: Margherita Pizza
struct MargheritaPizza;

impl Recipe for MargheritaPizza {
    fn prepare_ingredients(&amp;self) {
        println!(&quot;Gather ingredients for Margherita Pizza&quot;);
        println!(&quot;Prepare pizza dough&quot;);
        println!(&quot;Chop fresh tomatoes and basil leaves&quot;);
        println!(&quot;Grate mozzarella cheese&quot;);
    }

    fn cook(&amp;self) {
        println!(&quot;Roll out the pizza dough&quot;);
        println!(&quot;Spread tomato sauce on the dough&quot;);
        println!(&quot;Sprinkle mozzarella cheese on top&quot;);
        println!(&quot;Add fresh tomatoes and basil leaves&quot;);
        println!(&quot;Bake the pizza in the oven&quot;);
    }

    fn serve(&amp;self) {
        println!(&quot;Serve Margherita Pizza hot and fresh&quot;);
        println!(&quot;Enjoy!&quot;);
    }
}

fn main() {
    let pasta_carbonara = PastaCarbonara;
    pasta_carbonara.make_recipe();

    println!(&quot;------------------------&quot;);

    let margherita_pizza = MargheritaPizza;
    margherita_pizza.make_recipe();
}
</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
